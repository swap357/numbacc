# Trial 1: First Impressions of numbacc

**Date:** 2026-01-18
**Goal:** Clone, setup, and run the numbacc compiler project

---

## What Worked

### Frontend parsing and IR generation
- `python -m nbcc e2e.spy` successfully parses .spy files
- Produces readable intermediate representation
- Constant folding works (1+2 → 3 at compile time)
- Control flow decomposition into basic blocks works cleanly

### Dependency resolution (eventually)
- sealir and spy repos clone fine
- pip install -e works for all three packages
- libspy builds with zig (bundled via ziglang pip package - clever)

### Test suite (partial)
- Frontend tests pass: `pytest ./nbcc/frontend -v` → 5/5 passed
- Tests cover if/else, while, for/break/continue

---

## What Broke

### 1. checkout.sh uses invalid git flag
```bash
git clone $1 --revision="$2" --depth=1 "$3"
```
**Problem:** `--revision` is not a valid git clone option.
**Fix needed:** Clone first, then checkout the commit hash.

**Why does this matter?**
- This is the first command a new user runs (`make setup-workspace`)
- Immediate failure on first interaction = bad DX
- Suggests the script was written for a different git version or never tested on fresh clone

**Deeper question:** Why use a custom checkout script at all?
- Git submodules would handle this automatically
- Or a simple `git clone && git checkout` inline in Makefile
- The script adds complexity without adding value

### 2. Missing MLIR Python bindings
```
ModuleNotFoundError: No module named 'mlir'
```
**Problem:** Core E2E tests and compiler backend require `mlir-python-bindings`
**Source:** Only available via conda from `sklam` channel, not pip

**Why is this a problem?**
- Breaks the "just pip install" workflow
- Forces conda dependency for a Python project
- The mlir20/mlir21 environment files exist but aren't referenced in README

**Deeper question:** Is MLIR the right choice here?
- MLIR is powerful but has heavy dependencies
- Alternative: Generate LLVM IR directly via llvmlite (already a dependency of sealir)
- Alternative: Target Cranelift (Rust-based, but has Python bindings)
- Alternative: Just emit C and shell out to clang
- The SPy project already uses wasmtime - could target WASM directly without MLIR

### 3. Implicit dependency chain not documented
```
nbcc → sealir → numba_rvsdg, egglog, llvmlite
nbcc → spy → wasmtime, ziglang, many others
```
**Problem:** README says "pip install" but doesn't list transitive deps
**Reality:** Need ~50 packages including Playwright, Selenium (!?)

**Why Selenium for a compiler?**
- Comes from pytest-pyodide (browser-based Python testing)
- Suggests SPy targets web/WASM, but numbacc may not need this
- Could trim dev dependencies significantly

---

## What Needed Manual Work

### 1. Fixing the git clone
```bash
# Instead of make setup-workspace, had to run:
git clone https://github.com/numba/sealir deps/sealir
cd deps/sealir && git checkout 542a4e36...
# Same for spy
```

### 2. Building libspy
```bash
make -C ./deps/spy/spy/libspy
```
This isn't in the main README flow - you discover it from the error message.

### 3. Discovering the actual entry point
- README says `python -m nbcc.compile <source> <dest>`
- Reality: `nbcc.compile` doesn't exist as a module
- Actual entry point is `python -m nbcc <source>`
- The `__main__.py` only does frontend parsing, not full compilation

---

## Improvements Needed

### Tier 1: Fix the Broken Basics

1. **Fix checkout.sh** - Replace `--revision` with proper clone+checkout
2. **Update README** - Document actual working commands
3. **Add CLAUDE.md** - Quick-start for AI assistants / new devs

### Tier 2: Simplify Dependency Story

1. **Consider git submodules** instead of custom checkout script
   - Why: Standard tooling, works everywhere, `git clone --recursive` just works

2. **Split dev vs runtime deps**
   - pytest-pyodide, playwright, selenium shouldn't be required for basic usage
   - Create `pip install .[dev]` vs `pip install .`

3. **Vendor or document MLIR situation**
   - Either: Bundle pre-built mlir wheels
   - Or: Make MLIR optional (frontend-only mode works fine)
   - Or: Detailed conda instructions in README

### Tier 3: Architectural Questions

1. **Why SPy as the frontend language?**
   - SPy is a research language from the same team
   - Could numbacc just parse Python directly? (like Numba does)
   - The .spy syntax is 95% Python - why the separate parser?
   - **Possible answer:** SPy has stricter typing, easier to compile
   - **Counter:** Could use Python + type hints + runtime checks

2. **Why not just extend Numba?**
   - Numba already compiles Python to LLVM
   - numbacc seems to be rebuilding similar infrastructure
   - **Possible answer:** MLIR gives more optimization passes, tensor ops
   - **Possible answer:** Research vehicle for new compilation techniques
   - **Counter:** Significant duplication of effort

3. **The egglog dependency is interesting**
   - egglog = e-graphs + Datalog for optimization
   - This is cutting-edge PL research (egg, egglog from UW)
   - Suggests the real value is in novel optimization strategies
   - **Question:** Is the optimization research the point, and the compiler just a vehicle?

4. **WASM vs Native target priority**
   - libspy builds for WASM first (wasi target)
   - wasmtime is a core dependency
   - Yet MLIR backend suggests native codegen goal
   - **Unclear:** Is this a WASM compiler or native compiler or both?

---

## Meta: What is numbacc trying to be?

Reading between the lines:

1. **Surface level:** A compiler from typed Python to native code via MLIR
2. **One level deeper:** A research vehicle for e-graph optimization in compilers
3. **Deepest level:** Possibly a next-gen Numba that's more amenable to formal optimization

The project feels early-stage research, not production tooling. That's fine, but the README doesn't set that expectation.

---

## Action Items for Contribution

If I were to contribute:

1. [ ] PR to fix checkout.sh (5 min fix, high impact)
2. [ ] PR to update README with working instructions
3. [ ] Issue asking about MLIR wheel distribution
4. [ ] Issue asking about project goals/roadmap

---

## Time Spent

- Clone + initial failed attempts: 2 min
- Debugging checkout.sh: 3 min
- Manual dependency setup: 5 min
- Building libspy: 2 min
- Running examples: 3 min
- Understanding what it does: 5 min

**Total: ~20 min to first successful run**

With fixed docs, should be: **2-3 min**
